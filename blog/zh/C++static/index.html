<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=icon  href="/assets/favicon.ico"> <link rel=apple-touch-icon  sizes=180x180  href="/assets/apple-touch-icon.png"> <link rel=icon  type="image/png" sizes=32x32  href="/assets/favicon-32x32.png"> <link rel=icon  type="image/png" sizes=16x16  href="/assets/favicon-16x16.png"> <link rel=manifest  href="/assets/site.webmanifest"> <title>Alex's Blog | C++ Static关键字详解</title> <header> <a class=title  href="/"><h2>Alex</h2></a> <nav> <a href="/">Home</a> / <a href="/blog/zh">ZH-Blog</a> / <a href="/blog/en">EN-Blog</a> <div class=social-media > <a style="color: #126add;" href="https://github.com/baddate"><i class="fab fa-github"></i></a> <a style="color: #126add;" href="mailto:alexdemail@e.email"><i class="fas fa-envelope"></i></a> <a style="color: #126add;" href="https://twitter.com/realAlexHans"><i class="fab fa-twitter"></i></a> </div> </nav> </header> <main> <div class=container ><p>C&#43;&#43;的static有两种用法：面向过程程序设计中的static&#40;延续C语言&#41;和面向对象程序设计中的static。</p> <h2 id="面向过程"><a href="#面向过程">面向过程：</a></h2> <ol> <li><p>静态全局变量：</p> <ul> <li><p>该变量在全局数据区分配内存；</p> <li><p>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</p> <li><p>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；</p> <li><p>静态全局变量不能被其它文件所用；</p> <li><p>其它文件中可以定义相同名字的变量，不会发生冲突；</p> </ul> <li><p>静态局部变量：</p> <ul> <li><p>该变量在全局数据区分配内存；</p> <li><p>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</p> <li><p>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</p> <li><p>它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</p> </ul> <li><p>静态函数：</p> <ul> <li><p>在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</p> <li><p>其它文件中可以定义相同名字的函数，不会发生冲突；</p> </ul> </ol> <h2 id="面向对象"><a href="#面向对象">面向对象</a></h2> <ol> <li><p>静态数据成员</p> <ul> <li><p>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。</p> <li><p>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</p> <li><p>静态数据成员和普通数据成员一样遵从public,protected,private访问规则。</p> <li><p>静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。</p> <li><p>类的静态数据成员有两种访问形式:＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞</p> <li><p>静态数据成员初始化的格式为:＜数据类型＞＜类名＞::＜静态数据成员名＞&#61;＜值＞</p> <li><p>静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了;</p> <li><p>同全局变量相比，使用静态数据成员有两个优势:</p> <ol> <li><p>静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性;</p> <li><p>可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能;</p> </ol> </ul> <li><p>静态数据函数</p> <ul> <li><p>类体外的函数定义不能指定关键字static;</p> <li><p>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;</p> <li><p>非静态成员函数可以任意地访问静态成员函数和静态数据成员;</p> <li><p>静态成员函数不能访问非静态成员函数和非静态数据成员;</p> <li><p>调用静态成员函数，可以用成员访问操作符&#40;.&#41;和&#40;-&gt;&#41;为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式:＜类名＞::＜静态成员函数名＞（＜参数表＞）调用类的静态成员函数;</p> <li><p>由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长;</p> <li><p>静态成员函数可以继承和覆盖,但无法是虚函数</p> </ul> </ol> <h2 id=rerference ><a href="#rerference">Rerference</a></h2> <p>https://www.cnblogs.com/beyondanytime/archive/2012/06/08/2542315.html</p> </div> </main> </div> <footer> &copy; Alex. Made with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://julialang.org">The Julia Programming Language</a>. </footer>