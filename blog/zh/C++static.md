@def title = "C++ Static关键字详解"
@def published = "21 December 2019"
@def tags = ["Tips", "C++"]

C++的static有两种用法：面向过程程序设计中的static(延续C语言)和面向对象程序设计中的static。

## 面向过程：
1. 静态全局变量：
    - 该变量在全局数据区分配内存；
    - 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；
    - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；
    - 静态全局变量不能被其它文件所用；
    - 其它文件中可以定义相同名字的变量，不会发生冲突；
2. 静态局部变量：
    - 该变量在全局数据区分配内存；
    - 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
    - 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；
    - 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
3. 静态函数：
    - 在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
    - 其它文件中可以定义相同名字的函数，不会发生冲突；

## 面向对象
1. 静态数据成员
    - 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。
    - 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。
    - 静态数据成员和普通数据成员一样遵从public,protected,private访问规则。
    - 静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。
    - 类的静态数据成员有两种访问形式:＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞
    - 静态数据成员初始化的格式为:＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞
    - 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了;
    - 同全局变量相比，使用静态数据成员有两个优势:
        1. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性;
        2. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能;

2. 静态数据函数
    - 类体外的函数定义不能指定关键字static;
    - 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;
    - 非静态成员函数可以任意地访问静态成员函数和静态数据成员;
    - 静态成员函数不能访问非静态成员函数和非静态数据成员;
    - 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式:＜类名＞::＜静态成员函数名＞（＜参数表＞）调用类的静态成员函数;
    - 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长;
    - 静态成员函数可以继承和覆盖,但无法是虚函数

## Rerference
https://www.cnblogs.com/beyondanytime/archive/2012/06/08/2542315.html