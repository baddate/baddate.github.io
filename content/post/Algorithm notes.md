---
title: Algorithm Notes
tags: 
    - Algorithm
date: 2018-06-07 22:20:20
url: /notes/Algorithm
categories:
    - NOTES
---
_一些算法笔记_
<!-- more -->
# Algorithm Notes
## 算法复杂度
1. 不高于关系O
    n^3 + 2n +5 = O(n^3) 
2. 不低于关系Ω
    𝑛^2=Ω(𝑛 log⁡𝑛) 
3. 等于关系θ
    n^3 + 2n +5 = θ(n^3)    
    因为 n^3 + 2n +5 = O(n^3)   n^3 + 2n +5 = Ω(n^3)  
    所以 n^3 + 2n +5 = θ(n^3) 

*一个多项式函数与其首项等阶*     
*对数函数的阶比任一多项式函数阶要小*
    假设𝑝(𝑛)=𝑎_𝑘 𝑛^𝑘+𝑎_(𝑘−1) 𝑛^(𝑘−1)+⋯+𝑎_1 𝑛^1+𝑎_0是一个变量为n的多项式，其中系数𝑎_𝑘>0,那么𝑝(𝑛)=Θ(𝑛^𝑘 )


*数组检索问题*
__二分查找算法__
*子集合问题*???

---
## 分治算法
__Master定理__    
若 𝒏^log_𝒃⁡𝒂  更大，则 𝑻(𝒏)=𝚯(𝒏^log_𝒃⁡𝒂 )    
若 𝒇(𝒏)=𝚯(𝒏^log_𝒃⁡𝒂 )，即 𝒇(𝒏) 与 𝒏^log_𝒃⁡𝒂  同阶， 则有𝑻(𝒏)=𝚯(𝒏^log_𝒃⁡𝒂   log⁡𝒏 )=𝚯(𝒇(𝒏)  log⁡𝒏)    
若 𝒇(𝒏) 更大，则 𝑻(𝒏)=𝚯(𝒇(𝒏))    

*例题*    
*1. 求解 𝑻(𝒏)=𝟗𝑻(𝒏/𝟑)+𝒏*     
𝒂=𝟗, 𝒃=𝟑, 𝒇(𝒏)=𝒏, 𝒏^log_𝒃⁡𝒂 =𝒏^𝟐    
∵ 𝒇(𝒏)=𝒏< 𝚶(𝒏^((log_𝒃⁡𝒂)) )=𝒏^𝟐   
∴ 𝑻(𝒏)=𝚯(𝒏^log_𝒃⁡𝒂  )=𝚯(𝒏^𝟐 )

*2. 求解 𝑻(𝒏)=𝟑𝑻(𝒏/𝟒)+𝒏 log⁡𝒏*    
𝒂=𝟑, 𝒃=𝟒,   
𝒇(𝒏)=𝒏 log⁡𝒏， 𝒏^log_𝒃⁡𝒂 =𝒏^log_𝟒⁡𝟑 ≈𝒏^(𝟎.𝟕𝟗𝟑)   
∵ 𝒇(𝒏)=𝒏 log⁡𝒏≥𝒏= 𝚯(𝒏^log_𝒃⁡𝒂 )     
∴ 𝑻(𝒏)=𝚯(𝒇(𝒏))=𝚯(𝒏 log⁡𝒏 )      

__分治法思想__   

>   分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，_分而治之_。   
>   如果问题可分割成k个子问题，且这些子问题都可解，利用这些子问题可解出原问题的解，此分治法是_可行_的。

_分三步_
1. 分解
2. 合并
3. 特殊情况, 如数组只有一个元素时, 直接排序

**归并排序**  
_𝑻(𝒏)=𝚯(𝒏𝐥𝐨𝐠𝒏)_
**快速排序**       
_最好T(n)= O(nlogn) 最坏T(n)= O(n2)_
**大整数乘法**   
27-29   
**矩阵连乘**    
_Strassen算法_    
<https://www.geeksforgeeks.org/strassens-matrix-multiplication/>
30-34   
〖𝚯(𝒏〗^𝟑) --> 〖𝚯(𝒏〗^(𝟐.𝟖𝟏))
>将8个矩阵相乘转变成7个矩阵相乘 how????        


*实例*    
*Google公司股票问题*   
> 思路:   
> 1. 计算相邻两天的差价, 得到一个新数组, 进而原问题转化成了一个最大子数组问题
> 2. 最大子数组的位置只有3种情况: 1. 完全在A[low..mid], 2. 完全在A[mid+1..high], 3. 跨越中点


*卡车买苹果问题*   


    
## 动态规划
__原理__   
_与分治法的区别_: 
1. 子问题是相互关联的 
2. 子问题只求解一次,且可以重复使用        
- 初始解集合, 小规模解到大规模解    
- 自上而下归纳, 最优子结构-->最优解, 归纳公式     

**矩阵连乘**    
3-9          
12-19   

**钢条切割**    


**最长公共子序列**     
**最优二叉树**   
**流水作业问题**  
**0/1背包问题**     
